<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter Game</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <style>
        body { background: linear-gradient(180deg, #0f2027 0%, #2c5364 100%); }
        #game-container { margin: 0 auto; max-width: 540px; }
        .centered { text-align: center; }
    </style>
</head>
<body>
    <div class="container mt-4">
        <h2 class="centered mb-3" style="font-family: 'Fredoka One', cursive; color: #00eaff;">Space Shooter</h2>
        <div id="game-container"></div>
        <div class="centered mt-3">
            <a href="/kids/home/" class="btn btn-outline-primary">Back to Kids Home</a>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <script>
    function getGameSize() {
        let w = Math.min(window.innerWidth, 540);
        let h = Math.max(340, Math.min(window.innerHeight * 0.7, 600));
        return { width: w, height: h };
    }
    let gameSize = getGameSize();
    let score = 0;
    let gameOver = false;
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    class SpaceShooterScene extends Phaser.Scene {
        constructor() { super('SpaceShooterScene'); }
        preload() {
            // Load normal background music
            this.load.audio('bgMusic', '/media/movies/laserSmall_002.ogg');
            this.load.audio('powerupMusic', '/media/movies/laserLarge_003.ogg');
            this.load.audio('gameOverSound', '/media/movies/explosionCrunch_000.ogg');
            // Load cake image for triple fire powerup
            this.load.image('cakeImg', '/media/movies/cake.png');
            // Load burger image for round fire powerup
            this.load.image('burgerImg', '/media/movies/burger.png');
                // Load user-provided player image
                this.load.image('playerImg', '/media/movies/ship-1414822_640 (1).webp');
                // Load cow image for small red enemies
                this.load.image('cowImg', '/media/movies/cow.png');
                // Load duck image for big round enemies
                this.load.image('duckImg', '/media/movies/duck.png');
                // Load buffalo image for extra big round enemies
                this.load.image('buffaloImg', '/media/movies/buffalo.png');
                // Load ice-cream image for double bullet powerup
                this.load.image('iceCreamImg', '/media/movies/ice-cream.png');
                // Debug: log image loading events
                this.load.on('filecomplete-image-playerImg', function(key, type, data) {
                    console.log('Player image loaded:', key);
                });
                this.load.on('loaderror', function(file) {
                    console.log('Image load error:', file.src);
                });
        }
        create() {
            // Enemy speed scaling
            this.enemySpeedScale = 1;
            this.time.addEvent({
                delay: 15000,
                callback: () => {
                    this.enemySpeedScale += 0.08;
                },
                callbackScope: this,
                loop: true
            });
            // Prepare game over sound
            this.gameOverSound = this.sound.add('gameOverSound', { loop: false, volume: 1 });
            // Play normal background music in loop
            this.bgMusic = this.sound.add('bgMusic', { loop: true, volume: 1 });
            this.bgMusic.play();
            // Prepare powerup music (loop)
            this.powerupMusic = this.sound.add('powerupMusic', { loop: true, volume: 1 });
            this.bg = this.add.rectangle(0, 0, gameSize.width, gameSize.height, 0x0f2027).setOrigin(0);
            // Player as user-provided image (smaller scale for better fit)
            this.player = this.add.image(gameSize.width/2, gameSize.height-60, 'playerImg').setScale(0.11);
            this.player.speed = 6;
            this.cursors = this.input.keyboard.createCursorKeys();
            this.bullets = [];
            this.enemies = [];
            this.powerups = [];
            this.scoreText = this.add.text(20, 20, 'Score: 0', { fontSize: '24px', fill: '#00eaff', fontFamily: 'Fredoka One' });
            this.time.addEvent({ delay: 900, callback: this.spawnEnemy, callbackScope: this, loop: true });
            // In create(), spawn all powerups at random intervals (10-30s)
            this.powerups = [];
            this.spawnAnyPowerup = () => {
                const nextDelay = Phaser.Math.Between(10000, 30000);
                this.spawnPowerup(['double','triple','round']);
                this.time.addEvent({ delay: nextDelay, callback: this.spawnAnyPowerup, callbackScope: this });
            };
            this.spawnAnyPowerup();
            this.input.keyboard.on('keydown-SPACE', () => this.shoot(), this);

            // Automatic firing every 350ms
            this.shootTimer = this.time.addEvent({ delay: 350, callback: this.shoot, callbackScope: this, loop: true });

            // Touch controls for mobile
            if (isMobile) {
                this.leftBtn = this.add.text(30, gameSize.height-60, '◀', { fontSize: '38px', fill: '#fff', backgroundColor:'#00eaff', padding:{x:12,y:8}, borderRadius:12 }).setInteractive().setDepth(2);
                this.rightBtn = this.add.text(gameSize.width-70, gameSize.height-60, '▶', { fontSize: '38px', fill: '#fff', backgroundColor:'#00eaff', padding:{x:12,y:8}, borderRadius:12 }).setInteractive().setDepth(2);
                this.leftBtn.on('pointerdown', () => { this.player.moveLeft = true; });
                this.leftBtn.on('pointerup', () => { this.player.moveLeft = false; });
                this.rightBtn.on('pointerdown', () => { this.player.moveRight = true; });
                this.rightBtn.on('pointerup', () => { this.player.moveRight = false; });
            }
            this.fireMode = 'single';
        }
        shoot() {
            if (gameOver) return;
            if (this.fireMode === 'single') {
                const bullet = this.add.rectangle(this.player.x, this.player.y-30, 6, 18, 0xffffff);
                bullet.speed = 400;
                this.bullets.push(bullet);
            } else if (this.fireMode === 'double') {
                const bullet1 = this.add.rectangle(this.player.x-12, this.player.y-30, 6, 18, 0xffffff);
                const bullet2 = this.add.rectangle(this.player.x+12, this.player.y-30, 6, 18, 0xffffff);
                bullet1.speed = bullet2.speed = 400;
                this.bullets.push(bullet1, bullet2);
            } else if (this.fireMode === 'triple') {
                const bullet1 = this.add.rectangle(this.player.x-16, this.player.y-30, 6, 18, 0xffffff);
                const bullet2 = this.add.rectangle(this.player.x, this.player.y-30, 6, 18, 0xffffff);
                const bullet3 = this.add.rectangle(this.player.x+16, this.player.y-30, 6, 18, 0xffffff);
                bullet1.speed = bullet2.speed = bullet3.speed = 400;
                this.bullets.push(bullet1, bullet2, bullet3);
            } else if (this.fireMode === 'round') {
                // Fire in 5 directions
                for (let angle = -60; angle <= 60; angle += 30) {
                    const rad = Phaser.Math.DegToRad(angle);
                    const bullet = this.add.rectangle(this.player.x, this.player.y-30, 6, 18, 0xffffff);
                    bullet.speed = 400;
                    bullet.vx = Math.sin(rad) * bullet.speed;
                    bullet.vy = -Math.cos(rad) * bullet.speed;
                    this.bullets.push(bullet);
                }
            }
        }
        spawnEnemy() {
            if (gameOver) return;
            const x = Phaser.Math.Between(30, gameSize.width-30);
            // Randomly choose enemy type: small, big, or extra big (6 hitpoints)
            const rand = Math.random();
            let enemy;
            if (rand < 0.2) {
                // Extra big round enemy with 6 hitpoints, use buffalo image
                enemy = this.add.image(x, -20, 'buffaloImg').setScale(0.52);
                enemy.isBig = true;
                enemy.isExtraBig = true;
                enemy.health = 6;
                enemy.speed = 60 * this.enemySpeedScale;
                enemy.healthText = this.add.text(x-18, -60, '6', { fontSize: '24px', fill: '#222', fontWeight: 'bold', backgroundColor: '#ffe066', padding: { left: 8, right: 8, top: 2, bottom: 2 } });
                // Glow effect for healthText
                enemy.healthText.setShadow(2, 2, '#ff9800', 8, true, true);
            } else if (rand < 0.5) {
                // Use duck image for big round enemies
                enemy = this.add.image(x, -20, 'duckImg').setScale(0.42);
                enemy.isBig = true;
                enemy.health = 3;
                enemy.speed = 80 * this.enemySpeedScale;
                enemy.healthText = this.add.text(x-10, -40, '3', { fontSize: '18px', fill: '#222', fontWeight: 'bold', backgroundColor: '#ffe066', padding: { left: 6, right: 6, top: 2, bottom: 2 } });
                // Glow effect for healthText
                enemy.healthText.setShadow(2, 2, '#ff9800', 8, true, true);
            } else {
                // Use cow image for small red enemies
                enemy = this.add.image(x, -20, 'cowImg').setScale(0.30);
                enemy.isBig = false;
                enemy.health = 1;
                enemy.speed = 120 * this.enemySpeedScale;
            }
            this.enemies.push(enemy);
        }
        spawnPowerup(allowedTypes) {
            if (gameOver) return;
            const x = Phaser.Math.Between(40, gameSize.width-40);
            let type, color;
            if (!allowedTypes || allowedTypes.length === 0) {
                type = 'double'; color = 0x00ffea;
            } else {
                const idx = Math.floor(Math.random() * allowedTypes.length);
                type = allowedTypes[idx];
                if (type === 'double') color = 0x00ffea;
                else if (type === 'triple') color = 0xff00ea;
                else if (type === 'round') color = 0x00ff00;
            }
            let powerup;
            if (type === 'double') {
                powerup = this.add.image(x, -20, 'iceCreamImg').setScale(0.88);
            } else if (type === 'triple') {
                powerup = this.add.image(x, -20, 'cakeImg').setScale(0.88);
            } else if (type === 'round') {
                powerup = this.add.image(x, -20, 'burgerImg').setScale(0.89);
            } else {
                powerup = this.add.circle(x, -20, 16, color);
            }
            powerup.glowTween = this.tweens.add({ targets: powerup, alpha: 0.3, yoyo: true, repeat: -1, duration: 400 });
            powerup.type = type;
            powerup.speed = 100;
            this.powerups.push(powerup);
        }
        hitEnemy(bullet, enemy) {
            bullet.destroy();
            enemy.destroy();
            // Award different points for different enemy types
            let points = 10;
            if (enemy.isExtraBig) {
                points = 60;
            } else if (enemy.isBig) {
                points = 30;
            } else {
                points = 10;
            }
            score += points;
            this.scoreText.setText('Score: ' + score);
        }
        hitPlayer(player, enemy) {
            if (gameOver) return;
            gameOver = true;
            if (this.shootTimer) this.shootTimer.remove();
            // Flash player image red
            this.tweens.add({
                targets: player,
                tint: 0xff3333,
                duration: 300,
                yoyo: true,
                repeat: 2
            });
            this.add.text(gameSize.width/2, gameSize.height/2, 'Game Over!\nScore: '+score, {
                fontSize: '32px', fill: '#ff3333', fontFamily: 'Fredoka One', align: 'center'
            }).setOrigin(0.5).setDepth(3);
            // Stop all music
            if (this.bgMusic && this.bgMusic.isPlaying) this.bgMusic.stop();
            if (this.powerupMusic && this.powerupMusic.isPlaying) this.powerupMusic.stop();
            // Play game over sound, then stop it after it finishes
            if (this.gameOverSound) {
                this.gameOverSound.play();
                this.gameOverSound.once('complete', () => {
                    this.gameOverSound.stop();
                });
            }
            this.time.delayedCall(15000, () => location.reload(), [], this);
        }
        activatePowerup(type) {
            // Stop normal bg music and play powerup music in loop
            if (this.bgMusic && this.bgMusic.isPlaying) this.bgMusic.stop();
            if (this.powerupMusic) this.powerupMusic.play();
            // Cancel previous timer and switch fire mode immediately
            if (this.fireModeTimer) this.fireModeTimer.remove();
            // Set timer to revert music after powerup duration
            let duration = 6000;
            if (type === 'double' || type === 'triple') duration = 12000;
            if (type === 'round') duration = 15000;
            this.musicTimer = this.time.delayedCall(duration, () => {
                if (this.powerupMusic && this.powerupMusic.isPlaying) this.powerupMusic.stop();
                if (this.bgMusic && !this.bgMusic.isPlaying) this.bgMusic.play();
            }, [], this);
            // Cancel previous timer and switch fire mode immediately
            if (this.fireModeTimer) this.fireModeTimer.remove();
            if (type === 'double') {
                this.fireMode = 'double';
                this.fireModeTimer = this.time.delayedCall(12000, () => { this.fireMode = 'single'; }, [], this);
            } else if (type === 'triple') {
                this.fireMode = 'triple';
                this.fireModeTimer = this.time.delayedCall(12000, () => { this.fireMode = 'single'; }, [], this);
            } else if (type === 'round') {
                this.fireMode = 'round';
                this.fireModeTimer = this.time.delayedCall(15000, () => { this.fireMode = 'single'; }, [], this);
            }
        }
        update() {
            if (gameOver) return;
            // Player movement
            let moveLeft = this.cursors.left.isDown || (isMobile && this.player.moveLeft);
            let moveRight = this.cursors.right.isDown || (isMobile && this.player.moveRight);
            if (moveLeft) {
                this.player.x -= this.player.speed;
            } else if (moveRight) {
                this.player.x += this.player.speed;
            }
            // Keep player in bounds
            this.player.x = Phaser.Math.Clamp(this.player.x, 22, gameSize.width-22);
            // Move bullets
            for (let i = this.bullets.length-1; i >= 0; i--) {
                let bullet = this.bullets[i];
                if (this.fireMode === 'round' && bullet.vx !== undefined && bullet.vy !== undefined) {
                    bullet.x += bullet.vx * this.game.loop.delta / 1000;
                    bullet.y += bullet.vy * this.game.loop.delta / 1000;
                } else {
                    bullet.y -= bullet.speed * this.game.loop.delta / 1000;
                }
                if (bullet.y < -20 || bullet.x < -20 || bullet.x > gameSize.width+20) {
                    bullet.destroy();
                    this.bullets.splice(i, 1);
                }
            }
            // Move enemies
            for (let i = this.enemies.length-1; i >= 0; i--) {
                let enemy = this.enemies[i];
                enemy.y += enemy.speed * this.game.loop.delta / 1000;
                if (enemy.isBig && enemy.healthText) {
                    enemy.healthText.x = enemy.x-10;
                    enemy.healthText.y = enemy.y-40;
                }
                if (enemy.y > gameSize.height+40) {
                    if (enemy.isBig && enemy.healthText) enemy.healthText.destroy();
                    enemy.destroy();
                    this.enemies.splice(i, 1);
                }
            }
            // Move powerups
            for (let i = this.powerups.length-1; i >= 0; i--) {
                let powerup = this.powerups[i];
                powerup.y += powerup.speed * this.game.loop.delta / 1000;
                if (powerup.y > gameSize.height+40) {
                    powerup.glowTween.stop();
                    powerup.destroy();
                    this.powerups.splice(i, 1);
                }
                // Collision with player
                let dx = powerup.x - this.player.x;
                let dy = powerup.y - this.player.y;
                if (Math.sqrt(dx*dx + dy*dy) < 38) {
                    this.activatePowerup(powerup.type);
                    powerup.glowTween.stop();
                    powerup.destroy();
                    this.powerups.splice(i, 1);
                }
            }
            // Collision detection
            for (let i = this.enemies.length-1; i >= 0; i--) {
                let enemy = this.enemies[i];
                let enemyRadius = enemy.isBig ? 32 : 18;
                // Player collision
                let dx = enemy.x - this.player.x;
                let dy = enemy.y - this.player.y;
                if (Math.sqrt(dx*dx + dy*dy) < enemyRadius + 22) {
                    this.hitPlayer(this.player, enemy);
                }
                // Bullet collision
                for (let j = this.bullets.length-1; j >= 0; j--) {
                    let bullet = this.bullets[j];
                    let dx2 = enemy.x - bullet.x;
                    let dy2 = enemy.y - bullet.y;
                    if (Math.sqrt(dx2*dx2 + dy2*dy2) < enemyRadius + 6) {
                        // Reduce health for big enemies
                        if (enemy.isBig) {
                            enemy.health--;
                            enemy.healthText.setText(enemy.health);
                            bullet.destroy();
                            this.bullets.splice(j, 1);
                            if (enemy.health <= 0) {
                                enemy.healthText.destroy();
                                this.hitEnemy(bullet, enemy);
                                this.enemies.splice(i, 1);
                            }
                        } else {
                            this.hitEnemy(bullet, enemy);
                            this.enemies.splice(i, 1);
                            this.bullets.splice(j, 1);
                        }
                        break;
                    }
                }
            }
        }
    }
    new Phaser.Game({
        type: Phaser.AUTO,
        width: gameSize.width,
        height: gameSize.height,
        parent: 'game-container',
        physics: { default: 'arcade', arcade: { debug: false } },
        scene: SpaceShooterScene
    });
    </script>
</body>
</html>
